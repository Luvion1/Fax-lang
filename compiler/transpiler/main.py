import json
import sys
from datetime import datetime

class Transpiler:
    def __init__(self, ast):
        self.ast = ast
        self.indent_size = 4
        self.current_indent = 0
        self.user_functions = [f["name"] for f in ast["body"] if f["type"] == "FunctionDeclaration"]

    def emit_indent(self):
        return " " * (self.current_indent * self.indent_size)

    def generate(self, node, level=None):
        if not node: return ""
        if level is not None: self.current_indent = level
        
        t = node.get("type")
        
        # Dispatch table for cleaner structure
        dispatch = {
            "Program": self.gen_program,
            "FunctionDeclaration": self.gen_function,
            "VariableDeclaration": self.gen_variable,
            "BlockStatement": self.gen_block,
            "ExpressionStatement": lambda n: f"{self.emit_indent()}{self.generate(n['expression'])};",
            "IfStatement": self.gen_if,
            "WhileStatement": self.gen_while,
            "ForStatement": self.gen_for,
            "ReturnStatement": lambda n: f"{self.emit_indent()}return {self.generate(n['argument']) if n.get('argument') else ''};",
            "AssignmentExpression": lambda n: f"{self.generate(n['left'])} = {self.generate(n['right'])}",
            "BinaryExpression": lambda n: f"({self.generate(n['left'])} {n['operator']} {self.generate(n['right'])})",
            "UnaryExpression": lambda n: f"({n['operator']}{self.generate(n['argument'])})",
            "CallExpression": self.gen_call,
            "MemberExpression": lambda n: f"{self.generate(n['object'])}.{n['property']}",
            "IndexExpression": lambda n: f"{self.generate(n['object'])}[{self.generate(n['index'])}]",
            "Literal": self.gen_literal,
            "Identifier": lambda n: n["name"],
            "ArrayLiteral": lambda n: "{" + ", ".join([self.generate(e) for e in n["elements"]]) + "}"
        }
        
        func = dispatch.get(t)
        if func: return func(node)
        return f"/* Unknown Node: {t} */"

    def gen_literal(self, node):
        val = node["value"]
        if isinstance(val, str): return f'\"{val}\"'
        if isinstance(val, bool): return str(val).lower()
        return str(val)

    def gen_program(self, node):
        ts = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        header = (
            "/**\n"
            " * @file output.cpp\n"
            " * @brief High-quality C++ source auto-generated by Fax-lang\n"
            f" * @date {ts}\n"
            " */\n\n"
            "#include <iostream>\n"
            "#include <string>\n"
            "#include <vector>\n"
            "#include <stdexcept>\n\n"
            "namespace fax_app {\n"
        )
        
        body = ""
        # 1. Generate Prototypes if needed (optional for small projects)
        # 2. Generate Functions and Structs
        for stmt in node["body"]:
            if stmt["type"] in ["FunctionDeclaration", "StructDeclaration"]:
                body += self.generate(stmt, 1) + "\n"
        
        footer = "} // namespace fax_app\n\n"
        footer += (
            "int main(int argc, char* argv[]) {\n"
            "    try {\n"
        )
        
        main_logic = ""
        self.current_indent = 2
        for stmt in node["body"]:
            if stmt["type"] not in ["FunctionDeclaration", "StructDeclaration"]:
                if stmt["type"] == "ExpressionStatement" and \
                   stmt["expression"]["type"] == "CallExpression" and \
                   stmt["expression"]["callee"].get("name") == "main":
                    continue
                main_logic += self.generate(stmt) + "\n"
        
        if "main" in self.user_functions:
            main_logic += "        fax_app::main();\n"
            
        footer += main_logic
        footer += (
            "        return 0;\n"
            "    } catch (const std::exception& e) {\n"
            "        std::cerr << \"[FATAL]: \" << e.what() << std::endl;\n"
            "        return 1;\n"
            "    }\n"
            "}\n"
        )
        return header + body + footer

    def gen_function(self, node):
        ret = self.map_type(node["returnType"])
        name = node["name"]
        params = ", ".join([f"{self.map_type(p['type'])} {p['name']}" for p in node["params"]])
        
        doc = f"\n{self.emit_indent()}/**\n{self.emit_indent()} * @brief {name}\n{self.emit_indent()} */\n"
        code = f"{self.emit_indent()}{ret} {name}({params}) "
        code += self.generate(node["body"], self.current_indent)
        return doc + code

    def gen_block(self, node):
        code = "{\n"
        self.current_indent += 1
        for stmt in node["body"]:
            code += self.generate(stmt) + "\n"
        self.current_indent -= 1
        code += f"{self.emit_indent()}}}"
        return code

    def gen_variable(self, node):
        dtype = self.map_type(node["dataType"])
        init = f" = {self.generate(node['initializer'])}" if node.get("initializer") else ""
        return f"{self.emit_indent()}{dtype} {node['identifier']}{init};"

    def gen_if(self, node):
        code = f"{self.emit_indent()}if ({self.generate(node['test'])}) "
        code += self.generate(node["consequent"], self.current_indent).strip()
        if node.get("alternate"):
            code += " else "
            code += self.generate(node["alternate"], self.current_indent).strip()
        return code

    def gen_while(self, node):
        return f"{self.emit_indent()}while ({self.generate(node['test'])}) {self.generate(node['body'], self.current_indent).strip()}"

    def gen_for(self, node):
        init = self.generate(node["init"]).strip().replace(";", "") if node.get("init") else ""
        test = self.generate(node["test"]) if node.get("test") else ""
        update = self.generate(node["update"]) if node.get("update") else ""
        return f"{self.emit_indent()}for ({init}; {test}; {update}) {self.generate(node['body'], self.current_indent).strip()}"

    def gen_call(self, node):
        callee = self.generate(node["callee"])
        args = [self.generate(a) for a in node["arguments"]]
        if callee == "println":
            return f"std::cout << {" << \" \" << ".join(args)} << std::endl"
        if callee in self.user_functions and self.current_indent >= 2:
            return f"fax_app::{callee}({', '.join(args)})"
        return f"{callee}({', '.join(args)})"

    def map_type(self, fax_type):
        if not fax_type: return "auto"
        if fax_type.endswith("[]"):
            return f"std::vector<{self.map_type(fax_type.replace('[]', ''))}>"
        mapping = {"int": "int", "float": "float", "bool": "bool", "string": "std::string", "void": "void"}
        return mapping.get(fax_type, fax_type)

if __name__ == "__main__":
    if len(sys.argv) < 2: sys.exit(1)
    with open(sys.argv[1], 'r') as f:
        ast = json.load(f)
    print(Transpiler(ast).generate(ast))
/**
 * Fax-lang Transpiler - Corporate Standard Edition
 */

class Transpiler {
  constructor(ast, options = {}) {
    this.ast = ast;
    this.indentSize = options.indentSize || 4;
  }

  transpile() {
    return this.generate(this.ast);
  }

  indent(level) {
    return ' '.repeat(level * this.indentSize);
  }

  generate(node, level = 0) {
    if (!node) return '';

    switch (node.type) {
      case 'Program':
        return this.generateProgram(node);
      case 'VariableDeclaration':
        return this.generateVariableDeclaration(node, level);
      case 'FunctionDeclaration':
        return this.generateFunctionDeclaration(node, level);
      case 'StructDeclaration':
        return this.generateStructDeclaration(node, level);
      case 'BlockStatement':
        return this.generateBlock(node, level);
      case 'ExpressionStatement':
        return this.indent(level) + this.generate(node.expression, 0) + ';';
      case 'ReturnStatement':
        return this.indent(level) + 'return ' + (node.argument ? this.generate(node.argument, 0) : '') + ';';
      case 'IfStatement':
        return this.generateIfStatement(node, level);
      case 'WhileStatement':
        return this.indent(level) + 'while (' + this.generate(node.test, 0) + ') ' + this.generate(node.body, level).trimStart();
      case 'ForStatement':
        return this.generateForStatement(node, level);
      case 'AssignmentExpression':
        return this.generate(node.left, 0) + ' = ' + this.generate(node.right, 0);
      case 'BinaryExpression':
        return '(' + this.generate(node.left, 0) + ' ' + node.operator + ' ' + this.generate(node.right, 0) + ')';
      case 'UnaryExpression':
        return '(' + node.operator + this.generate(node.argument, 0) + ')';
      case 'MemberExpression':
        return this.generate(node.object, 0) + '.' + node.property;
      case 'IndexExpression':
        return this.generate(node.object, 0) + '[' + this.generate(node.index, 0) + ']';
      case 'CallExpression':
        return this.generateCallExpression(node, level);
      case 'Identifier':
        return node.name;
      case 'Literal':
        if (typeof node.value === 'string') return '"' + node.value + '"';
        return node.value.toString();
      case 'ArrayLiteral':
        return '{' + node.elements.map(el => this.generate(el, 0)).join(', ') + '}';
      default:
        return '/* Unknown node type: ' + node.type + ' */';
    }
  }

  generateProgram(node) {
    const timestamp = new Date().toISOString();
    let code = '/**\n * @file output.cpp\n * @brief Auto-generated by Fax-lang Compiler\n * @date ' + timestamp + '\n */\n\n';
    
    code += '#include <iostream>\n';
    code += '#include <string>\n';
    code += '#include <vector>\n';
    code += '#include <algorithm>\n\n';

    code += 'namespace fax_app {\n\n';
    
    const structs = node.body.filter(stmt => stmt.type === 'StructDeclaration');
    const functions = node.body.filter(stmt => stmt.type === 'FunctionDeclaration');
    const others = node.body.filter(stmt => stmt.type !== 'FunctionDeclaration' && stmt.type !== 'StructDeclaration');
    
    for (const st of structs) {
      code += this.generate(st, 1) + '\n\n';
    }

    for (const fn of functions) {
      code += this.generate(fn, 1) + '\n\n';
    }

    code += '} // namespace fax_app\n\n';
    
    code += 'int main(int argc, char* argv[]) {\n';
    code += '    try {\n';
    
    const hasMainInFax = functions.some(f => f.name === 'main');
    
    if (others.length > 0) {
        code += others.map(stmt => this.generate(stmt, 2)).join('\n') + '\n';
    }

    if (hasMainInFax) {
        code += '        fax_app::main();\n';
    }
    
    code += '        return 0;\n';
    code += '    } catch (const std::exception& e) {\n';
    code += '        std::cerr << "Runtime Error: " << e.what() << std::endl;\n';
    code += '        return 1;\n';
    code += '    }\n';
    code += '}\n';
    
    return code;
  }

  generateVariableDeclaration(node, level) {
    let type = this.mapType(node.dataType);
    let code = this.indent(level) + type + ' ' + node.identifier;
    if (node.initializer) {
      code += ' = ' + this.generate(node.initializer, 0);
    }
    return code + ';';
  }

  generateStructDeclaration(node, level) {
    let code = this.indent(level) + 'struct ' + node.name + ' {\n';
    for (const field of node.fields) {
      code += this.indent(level + 1) + this.mapType(field.type) + ' ' + field.name + ';\n';
    }
    code += this.indent(level) + '};';
    return code;
  }

  generateFunctionDeclaration(node, level) {
    let returnType = this.mapType(node.returnType);
    let params = node.params.map(p => this.mapType(p.type) + ' ' + p.name).join(', ');
    
    let code = this.indent(level) + returnType + ' ' + node.name + '(' + params + ') ';
    code += this.generate(node.body, level).trimStart();
    return code;
  }

  generateBlock(node, level) {
    let code = '{\n';
    for (const stmt of node.body) {
      code += this.generate(stmt, level + 1) + '\n';
    }
    code += this.indent(level) + '}';
    return code;
  }

  generateIfStatement(node, level) {
    let code = this.indent(level) + 'if (' + this.generate(node.test, 0) + ') ' + this.generate(node.consequent, level).trimStart();
    if (node.alternate) {
      code += ' else ';
      if (node.alternate.type === 'IfStatement') {
        code += this.generate(node.alternate, 0).trimStart();
      } else {
        code += this.generate(node.alternate, level).trimStart();
      }
    }
    return code;
  }

  generateForStatement(node, level) {
    const init = node.init ? this.generate(node.init, 0).replace(';', '') : '';
    const test = node.test ? this.generate(node.test, 0) : '';
    const update = node.update ? this.generate(node.update, 0) : '';
    return this.indent(level) + 'for (' + init + '; ' + test + '; ' + update + ') ' + this.generate(node.body, level).trimStart();
  }

  generateCallExpression(node, level) {
    const callee = this.generate(node.callee, 0);
    if (callee === 'println') {
      const args = node.arguments.map(arg => this.generate(arg, 0)).join(' << " " << ');
      return (level > 0 ? this.indent(level) : '') + 'std::cout << ' + args + ' << std::endl';
    }
    return (level > 0 ? this.indent(level) : '') + callee + '(' + node.arguments.map(arg => this.generate(arg, 0)).join(', ') + ')';
  }

  mapType(faxType) {
    if (!faxType) return 'auto';
    if (faxType.endsWith('[]')) {
      return 'std::vector<' + this.mapType(faxType.substring(0, faxType.length - 2)) + '>';
    }
    const typeMap = {
      'int': 'int',
      'float': 'float',
      'bool': 'bool',
      'string': 'std::string',
      'void': 'void',
      'auto': 'auto'
    };
    return typeMap[faxType] || faxType;
  }
}

module.exports = { Transpiler };
